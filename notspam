#!/usr/bin/env python

import os
import sys
import notmuch
import subprocess

############################################################

def usage():
    prog = os.path.basename(sys.argv[0])
    print "Usage:", prog, "<command> [args...]"
    print """
Commands:

  learn <meat> <search-terms>         Learn spam/ham (sa-learn).
                                      All messages returned from search will be
                                      learned as specified meat ('ham'/'spam').

  tag [options] [id:]<docid>          Tag messages as spam or ham (spamc).
    --spam=<tag>[,...]                  tags to apply to spam (default: 'spam')
    --ham=<tag>[,...]                   tags to apply to ham
    --dry                               dry run (no tags applied)

  help                                This help.
"""

############################################################

def sa_learn(mfile, meat):
    cmd = ["sa-learn",
           "--local",
           "--no-sync",
           '--'+meat,
           mfile
           ]
    subprocess.check_call(cmd, stdout=subprocess.PIPE)

def sa_sync():
    cmd = ["sa-learn",
           "--sync"
           ]
    subprocess.check_call(cmd)

def learn(meat, query_string, dry=False):
    db = notmuch.Database()

    query = db.create_query(query_string)

    for msg in query.search_messages():
        if not dry:
            print >>sys.stderr, meat+':',
            sa_learn(msg.get_filename(), meat)
        print >>sys.stderr, 'id:%s' % (msg.get_message_id())

    if not dry:
        sa_sync()

    db.close()

############################################################

class SpamcError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return repr(self.msg)

def spamc(mfile):
    cmd = ["/usr/bin/spamc",
           "--log-to-stderr",
           "--max-size=5000000",
           "--check",
           ]
    with open(mfile, 'r') as f:
        p = subprocess.Popen(cmd,
                             stdin=f,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             )
        (stdout, stderr) = p.communicate()
        ret = p.wait()
    # process the return code.
    # 1 == spam
    # 0 == ham or error
    score, threshold = stdout.strip().split('/')
    if ret == 1:
        isspam = True
    else:
        if stdout.strip() == '0/0':
            raise SpamcError(stderr.strip())
        isspam = False
    return isspam, float(score), float(threshold)

def tag_msg(msg, tag):
    if tag[0] == '+':
        msg.add_tag(tag[1:])
    elif tag[0] == '-':
        msg.remove_tag(tag[1:])
    else:
        msg.add_tag(tag)

def tag(query_string, spam_tags=['spam'], ham_tags=[], dry=True):
    """Process new mail as ham/spam"""

    # open the database READ.WRITE
    db = notmuch.Database(mode=1)

    query = db.create_query(query_string)

    for msg in query.search_messages():
        try:
            isspam, score, threshold = spamc(msg.get_filename())
        except SpamcError as e:
            print >>sys.stderr, 'spamc error: %s (id:%s)' % (e, msg.get_message_id())
            continue

        if isspam:
            flag = 'SPAM'
            tags = spam_tags
        else:
            flag = 'HAM'
            tags = ham_tags

        if dry:
            print >>sys.stderr, '%4s (% .1f/%.1f): id:%s' % (flag, score, threshold, msg.get_message_id())
        else:
            print >>sys.stderr, '%4s (% .1f/%.1f) %s: id:%s' % (flag, score, threshold, tags, msg.get_message_id())
            if tags:
                msg.freeze
                for tag in tags:
                    tag_msg(msg, tag)
                msg.thaw

############################################################

if __name__ == '__main__':

    if len(sys.argv) > 1:
        cmd = sys.argv[1]
    else:
        cmd = []

    ########################################
    if cmd in ['learn']:
        dry = False
        if len(sys.argv) < 4:
            print >>sys.stderr, "Must specify meat and search terms."
            sys.exit(1)
        argc = 2
        while True:
            if argc >= len(sys.argv):
                break
            elif '--dry' in sys.argv[argc]:
                dry = True
            else:
                break
            argc += 1
        meat = sys.argv[argc]
        query_string = ' '.join(sys.argv[argc+1:])
        if meat not in ['ham', 'spam']:
            print >>sys.stderr, "Meat must either be 'ham' or 'spam'."
            sys.exit(2)
        try:
            learn(meat, query_string, dry=dry)
        except KeyboardInterrupt:
            sys.exit()

    ########################################
    elif cmd in ['tag']:
        spam_tags = ['spam']
        ham_tags = []
        dry = False
        argc = 2
        while True:
            if argc >= len(sys.argv):
                break
            elif '--spam=' in sys.argv[argc]:
                spam = sys.argv[argc].split('=',1)[1].split(',')
            elif '--ham=' in sys.argv[argc]:
                ham_tags = sys.argv[argc].split('=',1)[1].split(',')
            elif '--dry' in sys.argv[argc]:
                dry = True
            else:
                break
            argc += 1

        query_string = ' '.join(sys.argv[argc:])
        try:
            tag(query_string, spam_tags=spam_tags, ham_tags=ham_tags, dry=dry)
        except KeyboardInterrupt:
            sys.exit()

    ########################################
    elif cmd in ['help','h']:
        usage()
        sys.exit(0)

    ########################################
    else:
        print >>sys.stderr, "Unknown sub command '%s'." % cmd
        usage()
        sys.exit(1)
