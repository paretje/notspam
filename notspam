#!/usr/bin/env python

import os
import sys
import notmuch
import subprocess

############################################################

def usage():
    prog = os.path.basename(sys.argv[0])
    print "Usage:", prog, "<command> [args...]"
    print """
Notmuch interface to the Spamassassin spam filtering system.

Commands:

  learn <meat> <search-terms>...    Learn spam/ham.
  tag [options] <search-terms>...   Tag messages as spam or ham.
    --spam=<tag>[,...]                tags to apply to spam
    --ham=<tag>[,...]                 tags to apply to ham
    --dry                             dry run (no tags applied)
  check <search-terms>             Synonym for 'tag --dry <search-terms>'.
  help                             This help.

Description:

  Learn: Messages returned from the specified notmuch search (see
  notmuch-search-terms(7)) will be piped to sa-learn(1) and classified
  as the specified meat ('ham' or 'spam').  The messages being learned
  will logged on stdout:

  <msg #>/<# msgs> id:<msg-id>

  Tag: Messages returned from the specified search will be classified
  as 'spam' or 'ham' via the spamc spamassassin client (see spamc(1)).
  This assumes a configured and running spamd daemon (see spamd(8)).
  Classifications will be logged to stdout in the following form:

  <msg #>/<# msgs> <meat> (<score>/<threshold>) [<applied tags>] id:<msg-id>
"""

############################################################

def sa_learn(meat):
    cmd = ["sa-learn",
           "--local",
           "--progress",
           "--no-sync",
           '--'+meat,
           "-f", "-",
           ]
    proc = subprocess.Popen(cmd,
                            stdin=subprocess.PIPE
                            )
    return proc

def sa_sync():
    cmd = ["sa-learn",
           "--sync"
           ]
    subprocess.check_call(cmd)

def learn(meat, query_string, dry=False):
    # open the database READ.WRITE, as this seems to be the only way
    # to lock the database, which we want to do during this long
    # operation.
    with notmuch.Database(mode=1) as db:

        query = db.create_query(query_string)

        nmsgs = query.count_messages()

        # initiate the sa-learn process
        if not dry:
            proc = sa_learn(meat)

        # write the message file paths to process stdin
        nmsg = 1
        for msg in query.search_messages():
            print '%d/%d id:%s' % (nmsg, nmsgs, msg.get_message_id())
            if not dry:
                proc.stdin.write(msg.get_filename() + '\n')
            nmsg += 1

    if not dry:
        # run the process and wait for return
        proc.communicate()
        ret = proc.wait()
        if ret != 0:
            print >>sys.stderr, 'Error during sa-learn call.'
            sys.exit(ret)

        # sync the sa database when done
        sa_sync()

############################################################

class SpamCheckError(Exception):
    def __init__(self, msg):
        self.msg = msg
    def __str__(self):
        return repr(self.msg)

def spamc(mfile):
    cmd = ["/usr/bin/spamc",
           "--log-to-stderr",
           "--max-size=5000000",
           "--check",
           ]
    with open(mfile, 'r') as f:
        proc = subprocess.Popen(cmd,
                                stdin=f,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE,
                                )
        (stdout, stderr) = proc.communicate()
        ret = proc.wait()
    # process the return code.
    # 1 == spam
    # 0 == ham or error
    score, threshold = stdout.strip().split('/')
    if ret == 1:
        isspam = True
    else:
        if stdout.strip() == '0/0':
            raise SpamCheckError(stderr.strip())
        isspam = False
    return isspam, float(score), float(threshold)

def tag_msg(msg, tag):
    if tag[0] == '+':
        msg.add_tag(tag[1:])
    elif tag[0] == '-':
        msg.remove_tag(tag[1:])
    else:
        msg.add_tag(tag)

def tag(query_string, spam_tags=[], ham_tags=[], dry=True):
    # open the database READ.WRITE
    with notmuch.Database(mode=1) as db:

        query = db.create_query(query_string)

        nmsgs = query.count_messages()

        nmsg = 1
        for msg in query.search_messages():
            try:
                isspam, score, threshold = spamc(msg.get_filename())
            except SpamCheckError as e:
                print >>sys.stderr, 'spamc error: %s (id:%s)' % (e, msg.get_message_id())
                continue

            if isspam:
                flag = 'SPAM'
                tags = spam_tags
            else:
                flag = 'HAM'
                tags = ham_tags

            print '%d/%d %4s (% .1f/%.1f)' % (nmsg, nmsgs, flag, score, threshold),
            if not dry:
                print '%s' % (tags),
                if tags:
                    msg.freeze
                    for tag in tags:
                        tag_msg(msg, tag)
                    msg.thaw
            print 'id:%s' % (msg.get_message_id())
            nmsg += 1

############################################################

if __name__ == '__main__':

    if len(sys.argv) > 1:
        cmd = sys.argv[1]
    else:
        cmd = []

    ########################################
    if cmd in ['learn']:
        dry = False
        if len(sys.argv) < 4:
            print >>sys.stderr, "Must specify meat and search terms."
            sys.exit(1)

        argc = 2
        while True:
            if argc >= len(sys.argv):
                break
            elif '--dry' in sys.argv[argc]:
                dry = True
            else:
                break
            argc += 1

        meat = sys.argv[argc]
        query_string = ' '.join(sys.argv[argc+1:])

        if meat not in ['ham', 'spam']:
            print >>sys.stderr, "Meat must either be 'ham' or 'spam'."
            sys.exit(2)
        try:
            learn(meat, query_string, dry=dry)
        except KeyboardInterrupt:
            sys.exit()

    ########################################
    elif cmd in ['tag']:
        spam_tags = []
        ham_tags = []
        dry = False
        argc = 2
        while True:
            if argc >= len(sys.argv):
                break
            elif '--spam=' in sys.argv[argc]:
                spam_tags = sys.argv[argc].split('=',1)[1].split(',')
            elif '--ham=' in sys.argv[argc]:
                ham_tags = sys.argv[argc].split('=',1)[1].split(',')
            elif '--dry' in sys.argv[argc]:
                dry = True
            else:
                break
            argc += 1

        query_string = ' '.join(sys.argv[argc:])

        try:
            tag(query_string, spam_tags=spam_tags, ham_tags=ham_tags, dry=dry)
        except KeyboardInterrupt:
            sys.exit()

    ########################################
    elif cmd in ['check']:
        query_string = ' '.join(sys.argv[2:])
        tag(query_string, dry=True)

    ########################################
    elif cmd in ['help','h','-h','--help']:
        usage()
        sys.exit(0)

    ########################################
    else:
        print >>sys.stderr, "Unknown sub command '%s'." % cmd
        usage()
        sys.exit(1)
